diff --git a/dist/worker/index.cjs b/dist/worker/index.cjs
index 871fa067630a51707a0ddc0e761537c0e6142311..75fdfb118e3fd263b0e9f939309c42eddeb719ea 100644
--- a/dist/worker/index.cjs
+++ b/dist/worker/index.cjs
@@ -5,5 +5,5 @@
       WHERE a.typcategory = 'A'
       GROUP BY b.oid, b.typarray
       ORDER BY b.oid
-    `);for(let n of t.rows)this.serializers[n.typarray]=i=>ge(i,this.serializers[n.oid],n.typarray),this.parsers[n.typarray]=i=>Ue(i,this.parsers[n.oid],n.typarray)}async refreshArrayTypes(){await this._initArrayTypes({force:!0})}async query(r,t,n){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await o(this,f,se).call(this,r,t,n))}async sql(r,...t){let{query:n,params:i}=de(r,...t);return await this.query(n,i)}async exec(r,t){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await o(this,f,C).call(this,r,t))}async describeQuery(r,t){try{await o(this,f,B).call(this,A.parse({text:r,types:t?.paramTypes}),t);let n=await o(this,f,B).call(this,A.describe({type:"S"}),t),i=n.messages.find(l=>l.name==="parameterDescription"),s=n.messages.find(l=>l.name==="rowDescription"),c=i?.dataTypeIDs.map(l=>({dataTypeID:l,serializer:this.serializers[l]}))??[],u=s?.fields.map(l=>({name:l.name,dataTypeID:l.dataTypeID,parser:this.parsers[l.dataTypeID]}))??[];return{queryParams:c,resultFields:u}}finally{await o(this,f,B).call(this,A.sync(),t)}}async transaction(r){return await this._checkReady(),await this._runExclusiveTransaction(async()=>{await o(this,f,C).call(this,"BEGIN"),d(this,k,!0);let t=!1,n=()=>{if(t)throw new Error("Transaction is closed")},i={query:async(s,c,u)=>(n(),await o(this,f,se).call(this,s,c,u)),sql:async(s,...c)=>{let{query:u,params:l}=de(s,...c);return await o(this,f,se).call(this,u,l)},exec:async(s,c)=>(n(),await o(this,f,C).call(this,s,c)),rollback:async()=>{n(),await o(this,f,C).call(this,"ROLLBACK"),t=!0},listen:async(s,c)=>(n(),await this.listen(s,c,i)),get closed(){return t}};try{let s=await r(i);return t||(t=!0,await o(this,f,C).call(this,"COMMIT")),d(this,k,!1),s}catch(s){throw t||await o(this,f,C).call(this,"ROLLBACK"),d(this,k,!1),s}})}async runExclusive(r){return await this._runExclusiveQuery(r)}};z=new WeakMap,k=new WeakMap,f=new WeakSet,B=async function(r,t={}){return await this.execProtocol(r,{...t,syncToFs:!1})},se=async function(r,t=[],n){return await this._runExclusiveQuery(async()=>{o(this,f,xe).call(this,"runQuery",r,t,n),await this._handleBlob(n?.blob);let i;try{let{messages:c}=await o(this,f,B).call(this,A.parse({text:r,types:n?.paramTypes}),n),u=we((await o(this,f,B).call(this,A.describe({type:"S"}),n)).messages),l=t.map((y,m)=>{let x=u[m];if(y==null)return null;let R=n?.serializers?.[x]??this.serializers[x];return R?R(y):y.toString()});i=[...c,...(await o(this,f,B).call(this,A.bind({values:l}),n)).messages,...(await o(this,f,B).call(this,A.describe({type:"P"}),n)).messages,...(await o(this,f,B).call(this,A.execute({}),n)).messages]}finally{await o(this,f,B).call(this,A.sync(),n)}await this._cleanupBlob(),a(this,k)||await this.syncToFs();let s=await this._getWrittenBlob();return be(i,this.parsers,n,s)[0]})},C=async function(r,t){return await this._runExclusiveQuery(async()=>{o(this,f,xe).call(this,"runExec",r,t),await this._handleBlob(t?.blob);let n;try{n=(await o(this,f,B).call(this,A.query(r),t)).messages}finally{await o(this,f,B).call(this,A.sync(),t)}this._cleanupBlob(),a(this,k)||await this.syncToFs();let i=await this._getWrittenBlob();return be(n,this.parsers,t,i)})},xe=function(...r){this.debug>0&&console.log(...r)};var wn=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var Pe=()=>{if(globalThis.crypto?.randomUUID)return globalThis.crypto.randomUUID();let e=new Uint8Array(16);if(globalThis.crypto?.getRandomValues)globalThis.crypto.getRandomValues(e);else for(let t=0;t<e.length;t++)e[t]=Math.floor(Math.random()*256);e[6]=e[6]&15|64,e[8]=e[8]&63|128;let r=[];return e.forEach(t=>{r.push(t.toString(16).padStart(2,"0"))}),r.slice(0,4).join("")+"-"+r.slice(4,6).join("")+"-"+r.slice(6,8).join("")+"-"+r.slice(8,10).join("")+"-"+r.slice(10).join("")};function We(e){let r;return e.startsWith('"')&&e.endsWith('"')?r=e.substring(1,e.length-1):r=e.toLowerCase(),r}var Q,$,j,q,H,D,v,O,S,Y,K,J,U,M,X,I,N,Z,ce,g,Fe,ie,E,Ge,Ee=class Ee extends ae{constructor(t,n){super();p(this,g);p(this,Q);p(this,$,0);p(this,j,!1);p(this,q,!1);p(this,H,!1);p(this,D,new EventTarget);p(this,v);p(this,O,!1);p(this,S);p(this,Y);p(this,K);p(this,J);p(this,U);p(this,M);p(this,X);p(this,I,new Map);p(this,N,new Set);p(this,Z);p(this,ce,[]);d(this,S,t),d(this,v,Pe()),d(this,Z,n?.extensions??{}),d(this,K,new Promise(i=>{a(this,S).addEventListener("message",s=>{if(s.data.type==="here")i();else throw new Error("Invalid message")},{once:!0})})),d(this,J,new Promise(i=>{let s=c=>{c.data.type==="ready"&&(d(this,Y,c.data.id),a(this,S).removeEventListener("message",s),i())};a(this,S).addEventListener("message",s)})),d(this,Q,o(this,g,Fe).call(this,n))}static async create(t,n){let i=new Ee(t,n);return await a(i,Q),i}get waitReady(){return new Promise(t=>{a(this,Q).then(()=>{a(this,O)?t():t(new Promise(n=>{a(this,D).addEventListener("connected",()=>{n()})}))})})}get debug(){return a(this,$)}get ready(){return a(this,j)}get closed(){return a(this,q)}get isLeader(){return a(this,H)}async close(){var t;a(this,q)||(d(this,q,!0),a(this,U)?.close(),a(this,M)?.close(),(t=a(this,X))==null||t.call(this),a(this,S).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(t){return await o(this,g,E).call(this,"execProtocolRaw",t)}async execProtocol(t){return await o(this,g,E).call(this,"execProtocol",t)}async syncToFs(){await o(this,g,E).call(this,"syncToFs")}async listen(t,n,i){let s=We(t),c=i??this;return a(this,I).has(s)||a(this,I).set(s,new Set),a(this,I).get(s).add(n),await c.exec(`LISTEN ${t}`),async u=>{await this.unlisten(s,n,u)}}async unlisten(t,n,i){await this.waitReady;let s=i??this;n?a(this,I).get(t)?.delete(n):a(this,I).delete(t),a(this,I).get(t)?.size===0&&await s.exec(`UNLISTEN ${t}`)}onNotification(t){return a(this,N).add(t),()=>{a(this,N).delete(t)}}offNotification(t){a(this,N).delete(t)}async dumpDataDir(){return await o(this,g,E).call(this,"dumpDataDir")}onLeaderChange(t){return a(this,D).addEventListener("leader-change",t),()=>{a(this,D).removeEventListener("leader-change",t)}}offLeaderChange(t){a(this,D).removeEventListener("leader-change",t)}async _handleBlob(t){await o(this,g,E).call(this,"_handleBlob",t)}async _getWrittenBlob(){return await o(this,g,E).call(this,"_getWrittenBlob")}async _cleanupBlob(){await o(this,g,E).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(t){await o(this,g,E).call(this,"_acquireQueryLock");try{return await t()}finally{await o(this,g,E).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(t){await o(this,g,E).call(this,"_acquireTransactionLock");try{return await t()}finally{await o(this,g,E).call(this,"_releaseTransactionLock")}}};Q=new WeakMap,$=new WeakMap,j=new WeakMap,q=new WeakMap,H=new WeakMap,D=new WeakMap,v=new WeakMap,O=new WeakMap,S=new WeakMap,Y=new WeakMap,K=new WeakMap,J=new WeakMap,U=new WeakMap,M=new WeakMap,X=new WeakMap,I=new WeakMap,N=new WeakMap,Z=new WeakMap,ce=new WeakMap,g=new WeakSet,Fe=async function(t={}){for(let[l,y]of Object.entries(a(this,Z))){if(y instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let m=await y.setup(this,{},!0);if(m.emscriptenOpts&&console.warn(`PGlite extension ${l} returned emscriptenOpts, these are not supported on the client side of a worker`),m.namespaceObj){let x=this;x[l]=m.namespaceObj}m.bundlePath&&console.warn(`PGlite extension ${l} returned bundlePath, this is not supported on the client side of a worker`),m.init&&await m.init(),m.close&&a(this,ce).push(m.close)}}await a(this,K);let{extensions:n,...i}=t;a(this,S).postMessage({type:"init",options:i}),await a(this,J);let s=`pglite-tab-close:${a(this,v)}`;d(this,X,await Re(s));let c=`pglite-broadcast:${a(this,Y)}`;d(this,U,new BroadcastChannel(c));let u=`pglite-tab:${a(this,v)}`;d(this,M,new BroadcastChannel(u)),a(this,U).addEventListener("message",async l=>{l.data.type==="leader-here"?(d(this,O,!1),a(this,D).dispatchEvent(new Event("leader-change")),o(this,g,ie).call(this)):l.data.type==="notify"&&o(this,g,Ge).call(this,l.data.channel,l.data.payload)}),a(this,M).addEventListener("message",async l=>{l.data.type==="connected"&&(d(this,O,!0),a(this,D).dispatchEvent(new Event("connected")),d(this,$,await o(this,g,E).call(this,"getDebugLevel")),d(this,j,!0))}),a(this,S).addEventListener("message",async l=>{l.data.type==="leader-now"&&(d(this,H,!0),a(this,D).dispatchEvent(new Event("leader-change")))}),o(this,g,ie).call(this),this._initArrayTypes()},ie=async function(){a(this,O)||(a(this,U).postMessage({type:"tab-here",id:a(this,v)}),setTimeout(()=>o(this,g,ie).call(this),16))},E=async function(t,...n){let i=Pe(),s={type:"rpc-call",callId:i,method:t,args:n};return a(this,M).postMessage(s),await new Promise((c,u)=>{let l=x=>{if(x.data.callId!==i)return;m();let R=x.data;if(R.type==="rpc-return")c(R.result);else if(R.type==="rpc-error"){let Be=new Error(R.error.message);Object.assign(Be,R.error),u(Be)}else u(new Error("Invalid message"))},y=()=>{m(),u(new oe)},m=()=>{a(this,M).removeEventListener("message",l),a(this,D).removeEventListener("leader-change",y)};a(this,D).addEventListener("leader-change",y),a(this,M).addEventListener("message",l)})},Ge=function(t,n){let i=a(this,I).get(t);if(i)for(let s of i)queueMicrotask(()=>s(n));for(let s of a(this,N))queueMicrotask(()=>s(t,n))};var Ae=Ee;async function Ft({init:e}){postMessage({type:"here"});let r=await new Promise(y=>{addEventListener("message",m=>{m.data.type==="init"&&y(m.data.options)},{once:!0})}),t=r.id??`${T}:${r.dataDir??""}`;postMessage({type:"ready",id:t});let n=`pglite-election-lock:${t}`,i=`pglite-broadcast:${t}`,s=new BroadcastChannel(i),c=new Set;await Re(n);let u=e(r);s.onmessage=async y=>{let m=y.data;switch(m.type){case"tab-here":Gt(m.id,await u,c);break}},s.postMessage({type:"leader-here",id:t}),postMessage({type:"leader-now"}),(await u).onNotification((y,m)=>{s.postMessage({type:"notify",channel:y,payload:m})})}function Gt(e,r,t){if(t.has(e))return;t.add(e);let n=`pglite-tab:${e}`,i=`pglite-tab-close:${e}`,s=new BroadcastChannel(n);navigator.locks.request(i,()=>new Promise(u=>{s.close(),t.delete(e),u()}));let c=Vt(e,r);s.addEventListener("message",async u=>{let l=u.data;switch(l.type){case"rpc-call":{await r.waitReady;let{callId:y,method:m,args:x}=l;try{let R=await c[m](...x);s.postMessage({type:"rpc-return",callId:y,result:R})}catch(R){console.error(R),s.postMessage({type:"rpc-error",callId:y,error:{message:R.message}})}break}}}),s.postMessage({type:"connected"})}function Vt(e,r){let t=null,n=null,i=`pglite-tab-close:${e}`;return Re(i).then(()=>{n&&r.exec("ROLLBACK"),t?.(),n?.()}),{async getDebugLevel(){return r.debug},async close(){await r.close()},async execProtocol(s){let{messages:c,data:u}=await r.execProtocol(s);if(u.byteLength!==u.buffer.byteLength){let l=new ArrayBuffer(u.byteLength),y=new Uint8Array(l);return y.set(u),{messages:c,data:y}}else return{messages:c,data:u}},async execProtocolRaw(s,c={}){let u=await r.execProtocolRaw(s,c);if(u.byteLength!==u.buffer.byteLength){let l=new ArrayBuffer(u.byteLength),y=new Uint8Array(l);return y.set(u),y}else return u},async dumpDataDir(){return await r.dumpDataDir()},async syncToFs(){return await r.syncToFs()},async _handleBlob(s){return await r._handleBlob(s)},async _getWrittenBlob(){return await r._getWrittenBlob()},async _cleanupBlob(){return await r._cleanupBlob()},async _checkReady(){return await r._checkReady()},async _acquireQueryLock(){return new Promise(s=>{r._runExclusiveQuery(()=>new Promise(c=>{t=c,s()}))})},async _releaseQueryLock(){t?.(),t=null},async _acquireTransactionLock(){return new Promise(s=>{r._runExclusiveTransaction(()=>new Promise(c=>{n=c,s()}))})},async _releaseTransactionLock(){n?.(),n=null}}}var oe=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function Re(e){let r;return await new Promise(t=>{navigator.locks.request(e,()=>new Promise(n=>{r=n,t()}))}),r}0&&(module.exports={LeaderChangedError,PGliteWorker,worker});
+    `);for(let n of t.rows)this.serializers[n.typarray]=i=>ge(i,this.serializers[n.oid],n.typarray),this.parsers[n.typarray]=i=>Ue(i,this.parsers[n.oid],n.typarray)}async refreshArrayTypes(){await this._initArrayTypes({force:!0})}async query(r,t,n){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await o(this,f,se).call(this,r,t,n))}async sql(r,...t){let{query:n,params:i}=de(r,...t);return await this.query(n,i)}async exec(r,t){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await o(this,f,C).call(this,r,t))}async describeQuery(r,t){try{await o(this,f,B).call(this,A.parse({text:r,types:t?.paramTypes}),t);let n=await o(this,f,B).call(this,A.describe({type:"S"}),t),i=n.messages.find(l=>l.name==="parameterDescription"),s=n.messages.find(l=>l.name==="rowDescription"),c=i?.dataTypeIDs.map(l=>({dataTypeID:l,serializer:this.serializers[l]}))??[],u=s?.fields.map(l=>({name:l.name,dataTypeID:l.dataTypeID,parser:this.parsers[l.dataTypeID]}))??[];return{queryParams:c,resultFields:u}}finally{await o(this,f,B).call(this,A.sync(),t)}}async transaction(r){return await this._checkReady(),await this._runExclusiveTransaction(async()=>{await o(this,f,C).call(this,"BEGIN"),d(this,k,!0);let t=!1,n=()=>{if(t)throw new Error("Transaction is closed")},i={query:async(s,c,u)=>(n(),await o(this,f,se).call(this,s,c,u)),sql:async(s,...c)=>{let{query:u,params:l}=de(s,...c);return await o(this,f,se).call(this,u,l)},exec:async(s,c)=>(n(),await o(this,f,C).call(this,s,c)),rollback:async()=>{n(),await o(this,f,C).call(this,"ROLLBACK"),t=!0},listen:async(s,c)=>(n(),await this.listen(s,c,i)),get closed(){return t}};try{let s=await r(i);return t||(t=!0,await o(this,f,C).call(this,"COMMIT")),d(this,k,!1),s}catch(s){throw t||await o(this,f,C).call(this,"ROLLBACK"),d(this,k,!1),s}})}async runExclusive(r){return await this._runExclusiveQuery(r)}};z=new WeakMap,k=new WeakMap,f=new WeakSet,B=async function(r,t={}){return await this.execProtocol(r,{...t,syncToFs:!1})},se=async function(r,t=[],n){return await this._runExclusiveQuery(async()=>{o(this,f,xe).call(this,"runQuery",r,t,n),await this._handleBlob(n?.blob);let i;try{let{messages:c}=await o(this,f,B).call(this,A.parse({text:r,types:n?.paramTypes}),n),u=we((await o(this,f,B).call(this,A.describe({type:"S"}),n)).messages),l=t.map((y,m)=>{let x=u[m];if(y==null)return null;let R=n?.serializers?.[x]??this.serializers[x];return R?R(y):y.toString()});i=[...c,...(await o(this,f,B).call(this,A.bind({values:l}),n)).messages,...(await o(this,f,B).call(this,A.describe({type:"P"}),n)).messages,...(await o(this,f,B).call(this,A.execute({}),n)).messages]}finally{await o(this,f,B).call(this,A.sync(),n)}await this._cleanupBlob(),a(this,k)||await this.syncToFs();let s=await this._getWrittenBlob();return be(i,this.parsers,n,s)[0]})},C=async function(r,t){return await this._runExclusiveQuery(async()=>{o(this,f,xe).call(this,"runExec",r,t),await this._handleBlob(t?.blob);let n;try{n=(await o(this,f,B).call(this,A.query(r),t)).messages}finally{await o(this,f,B).call(this,A.sync(),t)}this._cleanupBlob(),a(this,k)||await this.syncToFs();let i=await this._getWrittenBlob();return be(n,this.parsers,t,i)})},xe=function(...r){this.debug>0&&console.log(...r)};var wn=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var Pe=()=>{if(globalThis.crypto?.randomUUID)return globalThis.crypto.randomUUID();let e=new Uint8Array(16);if(globalThis.crypto?.getRandomValues)globalThis.crypto.getRandomValues(e);else for(let t=0;t<e.length;t++)e[t]=Math.floor(Math.random()*256);e[6]=e[6]&15|64,e[8]=e[8]&63|128;let r=[];return e.forEach(t=>{r.push(t.toString(16).padStart(2,"0"))}),r.slice(0,4).join("")+"-"+r.slice(4,6).join("")+"-"+r.slice(6,8).join("")+"-"+r.slice(8,10).join("")+"-"+r.slice(10).join("")};function We(e){let r;return e.startsWith('"')&&e.endsWith('"')?r=e.substring(1,e.length-1):r=e.toLowerCase(),r}var Q,$,j,q,H,D,v,O,S,Y,K,J,U,M,X,I,N,Z,ce,g,Fe,ie,E,Ge,Ee=class Ee extends ae{constructor(t,n){super();p(this,g);p(this,Q);p(this,$,0);p(this,j,!1);p(this,q,!1);p(this,H,!1);p(this,D,new EventTarget);p(this,v);p(this,O,!1);p(this,S);p(this,Y);p(this,K);p(this,J);p(this,U);p(this,M);p(this,X);p(this,I,new Map);p(this,N,new Set);p(this,Z);p(this,ce,[]);d(this,S,t),d(this,v,Pe()),d(this,Z,n?.extensions??{}),d(this,K,new Promise(i=>{a(this,S).addEventListener("message",s=>{if(s.data.type==="here")i();else throw new Error("Invalid message")},{once:!0})})),d(this,J,new Promise(i=>{let s=c=>{c.data.type==="ready"&&(d(this,Y,c.data.id),a(this,S).removeEventListener("message",s),i())};a(this,S).addEventListener("message",s)})),d(this,Q,o(this,g,Fe).call(this,n))}static async create(t,n){let i=new Ee(t,n);return await a(i,Q),i}get waitReady(){return new Promise(t=>{a(this,Q).then(()=>{a(this,O)?t():t(new Promise(n=>{a(this,D).addEventListener("connected",()=>{n()})}))})})}get debug(){return a(this,$)}get ready(){return a(this,j)}get closed(){return a(this,q)}get isLeader(){return a(this,H)}async close(){var t;a(this,q)||(d(this,q,!0),a(this,U)?.close(),a(this,M)?.close(),(t=a(this,X))==null||t.call(this),a(this,S).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(t){return await o(this,g,E).call(this,"execProtocolRaw",t)}async execProtocol(t){return await o(this,g,E).call(this,"execProtocol",t)}async syncToFs(){await o(this,g,E).call(this,"syncToFs")}async listen(t,n,i){let s=We(t),c=i??this;return a(this,I).has(s)||a(this,I).set(s,new Set),a(this,I).get(s).add(n),await c.exec(`LISTEN ${t}`),async u=>{await this.unlisten(s,n,u)}}async unlisten(t,n,i){await this.waitReady;let s=i??this;n?a(this,I).get(t)?.delete(n):a(this,I).delete(t),a(this,I).get(t)?.size===0&&await s.exec(`UNLISTEN ${t}`)}onNotification(t){return a(this,N).add(t),()=>{a(this,N).delete(t)}}offNotification(t){a(this,N).delete(t)}async dumpDataDir(compression){return await o(this,g,E).call(this,"dumpDataDir", compression)}onLeaderChange(t){return a(this,D).addEventListener("leader-change",t),()=>{a(this,D).removeEventListener("leader-change",t)}}offLeaderChange(t){a(this,D).removeEventListener("leader-change",t)}async _handleBlob(t){await o(this,g,E).call(this,"_handleBlob",t)}async _getWrittenBlob(){return await o(this,g,E).call(this,"_getWrittenBlob")}async _cleanupBlob(){await o(this,g,E).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(t){await o(this,g,E).call(this,"_acquireQueryLock");try{return await t()}finally{await o(this,g,E).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(t){await o(this,g,E).call(this,"_acquireTransactionLock");try{return await t()}finally{await o(this,g,E).call(this,"_releaseTransactionLock")}}};Q=new WeakMap,$=new WeakMap,j=new WeakMap,q=new WeakMap,H=new WeakMap,D=new WeakMap,v=new WeakMap,O=new WeakMap,S=new WeakMap,Y=new WeakMap,K=new WeakMap,J=new WeakMap,U=new WeakMap,M=new WeakMap,X=new WeakMap,I=new WeakMap,N=new WeakMap,Z=new WeakMap,ce=new WeakMap,g=new WeakSet,Fe=async function(t={}){for(let[l,y]of Object.entries(a(this,Z))){if(y instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let m=await y.setup(this,{},!0);if(m.emscriptenOpts&&console.warn(`PGlite extension ${l} returned emscriptenOpts, these are not supported on the client side of a worker`),m.namespaceObj){let x=this;x[l]=m.namespaceObj}m.bundlePath&&console.warn(`PGlite extension ${l} returned bundlePath, this is not supported on the client side of a worker`),m.init&&await m.init(),m.close&&a(this,ce).push(m.close)}}await a(this,K);let{extensions:n,...i}=t;a(this,S).postMessage({type:"init",options:i}),await a(this,J);let s=`pglite-tab-close:${a(this,v)}`;d(this,X,await Re(s));let c=`pglite-broadcast:${a(this,Y)}`;d(this,U,new BroadcastChannel(c));let u=`pglite-tab:${a(this,v)}`;d(this,M,new BroadcastChannel(u)),a(this,U).addEventListener("message",async l=>{l.data.type==="leader-here"?(d(this,O,!1),a(this,D).dispatchEvent(new Event("leader-change")),o(this,g,ie).call(this)):l.data.type==="notify"&&o(this,g,Ge).call(this,l.data.channel,l.data.payload)}),a(this,M).addEventListener("message",async l=>{l.data.type==="connected"&&(d(this,O,!0),a(this,D).dispatchEvent(new Event("connected")),d(this,$,await o(this,g,E).call(this,"getDebugLevel")),d(this,j,!0))}),a(this,S).addEventListener("message",async l=>{l.data.type==="leader-now"&&(d(this,H,!0),a(this,D).dispatchEvent(new Event("leader-change")))}),o(this,g,ie).call(this),this._initArrayTypes()},ie=async function(){a(this,O)||(a(this,U).postMessage({type:"tab-here",id:a(this,v)}),setTimeout(()=>o(this,g,ie).call(this),16))},E=async function(t,...n){let i=Pe(),s={type:"rpc-call",callId:i,method:t,args:n};return a(this,M).postMessage(s),await new Promise((c,u)=>{let l=x=>{if(x.data.callId!==i)return;m();let R=x.data;if(R.type==="rpc-return")c(R.result);else if(R.type==="rpc-error"){let Be=new Error(R.error.message);Object.assign(Be,R.error),u(Be)}else u(new Error("Invalid message"))},y=()=>{m(),u(new oe)},m=()=>{a(this,M).removeEventListener("message",l),a(this,D).removeEventListener("leader-change",y)};a(this,D).addEventListener("leader-change",y),a(this,M).addEventListener("message",l)})},Ge=function(t,n){let i=a(this,I).get(t);if(i)for(let s of i)queueMicrotask(()=>s(n));for(let s of a(this,N))queueMicrotask(()=>s(t,n))};var Ae=Ee;async function Ft({init:e}){postMessage({type:"here"});let r=await new Promise(y=>{addEventListener("message",m=>{m.data.type==="init"&&y(m.data.options)},{once:!0})}),t=r.id??`${T}:${r.dataDir??""}`;postMessage({type:"ready",id:t});let n=`pglite-election-lock:${t}`,i=`pglite-broadcast:${t}`,s=new BroadcastChannel(i),c=new Set;await Re(n);let u=e(r);s.onmessage=async y=>{let m=y.data;switch(m.type){case"tab-here":Gt(m.id,await u,c);break}},s.postMessage({type:"leader-here",id:t}),postMessage({type:"leader-now"}),(await u).onNotification((y,m)=>{s.postMessage({type:"notify",channel:y,payload:m})})}function Gt(e,r,t){if(t.has(e))return;t.add(e);let n=`pglite-tab:${e}`,i=`pglite-tab-close:${e}`,s=new BroadcastChannel(n);navigator.locks.request(i,()=>new Promise(u=>{s.close(),t.delete(e),u()}));let c=Vt(e,r);s.addEventListener("message",async u=>{let l=u.data;switch(l.type){case"rpc-call":{await r.waitReady;let{callId:y,method:m,args:x}=l;try{let R=await c[m](...x);s.postMessage({type:"rpc-return",callId:y,result:R})}catch(R){console.error(R),s.postMessage({type:"rpc-error",callId:y,error:{message:R.message}})}break}}}),s.postMessage({type:"connected"})}function Vt(e,r){let t=null,n=null,i=`pglite-tab-close:${e}`;return Re(i).then(()=>{n&&r.exec("ROLLBACK"),t?.(),n?.()}),{async getDebugLevel(){return r.debug},async close(){await r.close()},async execProtocol(s){let{messages:c,data:u}=await r.execProtocol(s);if(u.byteLength!==u.buffer.byteLength){let l=new ArrayBuffer(u.byteLength),y=new Uint8Array(l);return y.set(u),{messages:c,data:y}}else return{messages:c,data:u}},async execProtocolRaw(s,c={}){let u=await r.execProtocolRaw(s,c);if(u.byteLength!==u.buffer.byteLength){let l=new ArrayBuffer(u.byteLength),y=new Uint8Array(l);return y.set(u),y}else return u},async dumpDataDir(compression){return await r.dumpDataDir(compression)},async syncToFs(){return await r.syncToFs()},async _handleBlob(s){return await r._handleBlob(s)},async _getWrittenBlob(){return await r._getWrittenBlob()},async _cleanupBlob(){return await r._cleanupBlob()},async _checkReady(){return await r._checkReady()},async _acquireQueryLock(){return new Promise(s=>{r._runExclusiveQuery(()=>new Promise(c=>{t=c,s()}))})},async _releaseQueryLock(){t?.(),t=null},async _acquireTransactionLock(){return new Promise(s=>{r._runExclusiveTransaction(()=>new Promise(c=>{n=c,s()}))})},async _releaseTransactionLock(){n?.(),n=null}}}var oe=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function Re(e){let r;return await new Promise(t=>{navigator.locks.request(e,()=>new Promise(n=>{r=n,t()}))}),r}0&&(module.exports={LeaderChangedError,PGliteWorker,worker});
 //# sourceMappingURL=index.cjs.map
\ No newline at end of file
diff --git a/dist/worker/index.js b/dist/worker/index.js
index 1e3df9bdaeac756ff7c5f55bb66a4b200fb6eb10..0cc2ccf62ac19629726186d555e4ac9b85ad4ec1 100644
--- a/dist/worker/index.js
+++ b/dist/worker/index.js
@@ -1,2 +1,2 @@
-import{a as j}from"../chunk-6JG4A6NZ.js";import{u as N,x as z}from"../chunk-4LH4BY34.js";import"../chunk-STOZMFXW.js";import{e as t,f as h,g as u,h as y,j as Q}from"../chunk-BTBUZ646.js";Q();var W,T,C,M,_,m,L,x,k,B,A,O,E,v,G,P,b,I,$,c,K,D,w,J,F=class F extends j{constructor(e,r){super();h(this,c);h(this,W);h(this,T,0);h(this,C,!1);h(this,M,!1);h(this,_,!1);h(this,m,new EventTarget);h(this,L);h(this,x,!1);h(this,k);h(this,B);h(this,A);h(this,O);h(this,E);h(this,v);h(this,G);h(this,P,new Map);h(this,b,new Set);h(this,I);h(this,$,[]);u(this,k,e),u(this,L,N()),u(this,I,r?.extensions??{}),u(this,A,new Promise(a=>{t(this,k).addEventListener("message",s=>{if(s.data.type==="here")a();else throw new Error("Invalid message")},{once:!0})})),u(this,O,new Promise(a=>{let s=l=>{l.data.type==="ready"&&(u(this,B,l.data.id),t(this,k).removeEventListener("message",s),a())};t(this,k).addEventListener("message",s)})),u(this,W,y(this,c,K).call(this,r))}static async create(e,r){let a=new F(e,r);return await t(a,W),a}get waitReady(){return new Promise(e=>{t(this,W).then(()=>{t(this,x)?e():e(new Promise(r=>{t(this,m).addEventListener("connected",()=>{r()})}))})})}get debug(){return t(this,T)}get ready(){return t(this,C)}get closed(){return t(this,M)}get isLeader(){return t(this,_)}async close(){var e;t(this,M)||(u(this,M,!0),t(this,E)?.close(),t(this,v)?.close(),(e=t(this,G))==null||e.call(this),t(this,k).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await y(this,c,w).call(this,"execProtocolRaw",e)}async execProtocol(e){return await y(this,c,w).call(this,"execProtocol",e)}async syncToFs(){await y(this,c,w).call(this,"syncToFs")}async listen(e,r,a){let s=z(e),l=a??this;return t(this,P).has(s)||t(this,P).set(s,new Set),t(this,P).get(s).add(r),await l.exec(`LISTEN ${e}`),async n=>{await this.unlisten(s,r,n)}}async unlisten(e,r,a){await this.waitReady;let s=a??this;r?t(this,P).get(e)?.delete(r):t(this,P).delete(e),t(this,P).get(e)?.size===0&&await s.exec(`UNLISTEN ${e}`)}onNotification(e){return t(this,b).add(e),()=>{t(this,b).delete(e)}}offNotification(e){t(this,b).delete(e)}async dumpDataDir(){return await y(this,c,w).call(this,"dumpDataDir")}onLeaderChange(e){return t(this,m).addEventListener("leader-change",e),()=>{t(this,m).removeEventListener("leader-change",e)}}offLeaderChange(e){t(this,m).removeEventListener("leader-change",e)}async _handleBlob(e){await y(this,c,w).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await y(this,c,w).call(this,"_getWrittenBlob")}async _cleanupBlob(){await y(this,c,w).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await y(this,c,w).call(this,"_acquireQueryLock");try{return await e()}finally{await y(this,c,w).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await y(this,c,w).call(this,"_acquireTransactionLock");try{return await e()}finally{await y(this,c,w).call(this,"_releaseTransactionLock")}}};W=new WeakMap,T=new WeakMap,C=new WeakMap,M=new WeakMap,_=new WeakMap,m=new WeakMap,L=new WeakMap,x=new WeakMap,k=new WeakMap,B=new WeakMap,A=new WeakMap,O=new WeakMap,E=new WeakMap,v=new WeakMap,G=new WeakMap,P=new WeakMap,b=new WeakMap,I=new WeakMap,$=new WeakMap,c=new WeakSet,K=async function(e={}){for(let[o,p]of Object.entries(t(this,I))){if(p instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let d=await p.setup(this,{},!0);if(d.emscriptenOpts&&console.warn(`PGlite extension ${o} returned emscriptenOpts, these are not supported on the client side of a worker`),d.namespaceObj){let R=this;R[o]=d.namespaceObj}d.bundlePath&&console.warn(`PGlite extension ${o} returned bundlePath, this is not supported on the client side of a worker`),d.init&&await d.init(),d.close&&t(this,$).push(d.close)}}await t(this,A);let{extensions:r,...a}=e;t(this,k).postMessage({type:"init",options:a}),await t(this,O);let s=`pglite-tab-close:${t(this,L)}`;u(this,G,await q(s));let l=`pglite-broadcast:${t(this,B)}`;u(this,E,new BroadcastChannel(l));let n=`pglite-tab:${t(this,L)}`;u(this,v,new BroadcastChannel(n)),t(this,E).addEventListener("message",async o=>{o.data.type==="leader-here"?(u(this,x,!1),t(this,m).dispatchEvent(new Event("leader-change")),y(this,c,D).call(this)):o.data.type==="notify"&&y(this,c,J).call(this,o.data.channel,o.data.payload)}),t(this,v).addEventListener("message",async o=>{o.data.type==="connected"&&(u(this,x,!0),t(this,m).dispatchEvent(new Event("connected")),u(this,T,await y(this,c,w).call(this,"getDebugLevel")),u(this,C,!0))}),t(this,k).addEventListener("message",async o=>{o.data.type==="leader-now"&&(u(this,_,!0),t(this,m).dispatchEvent(new Event("leader-change")))}),y(this,c,D).call(this),this._initArrayTypes()},D=async function(){t(this,x)||(t(this,E).postMessage({type:"tab-here",id:t(this,L)}),setTimeout(()=>y(this,c,D).call(this),16))},w=async function(e,...r){let a=N(),s={type:"rpc-call",callId:a,method:e,args:r};return t(this,v).postMessage(s),await new Promise((l,n)=>{let o=R=>{if(R.data.callId!==a)return;d();let f=R.data;if(f.type==="rpc-return")l(f.result);else if(f.type==="rpc-error"){let S=new Error(f.error.message);Object.assign(S,f.error),n(S)}else n(new Error("Invalid message"))},p=()=>{d(),n(new U)},d=()=>{t(this,v).removeEventListener("message",o),t(this,m).removeEventListener("leader-change",p)};t(this,m).addEventListener("leader-change",p),t(this,v).addEventListener("message",o)})},J=function(e,r){let a=t(this,P).get(e);if(a)for(let s of a)queueMicrotask(()=>s(r));for(let s of t(this,b))queueMicrotask(()=>s(e,r))};var H=F;async function se({init:g}){postMessage({type:"here"});let i=await new Promise(p=>{addEventListener("message",d=>{d.data.type==="init"&&p(d.data.options)},{once:!0})}),e=i.id??`${import.meta.url}:${i.dataDir??""}`;postMessage({type:"ready",id:e});let r=`pglite-election-lock:${e}`,a=`pglite-broadcast:${e}`,s=new BroadcastChannel(a),l=new Set;await q(r);let n=g(i);s.onmessage=async p=>{let d=p.data;switch(d.type){case"tab-here":V(d.id,await n,l);break}},s.postMessage({type:"leader-here",id:e}),postMessage({type:"leader-now"}),(await n).onNotification((p,d)=>{s.postMessage({type:"notify",channel:p,payload:d})})}function V(g,i,e){if(e.has(g))return;e.add(g);let r=`pglite-tab:${g}`,a=`pglite-tab-close:${g}`,s=new BroadcastChannel(r);navigator.locks.request(a,()=>new Promise(n=>{s.close(),e.delete(g),n()}));let l=X(g,i);s.addEventListener("message",async n=>{let o=n.data;switch(o.type){case"rpc-call":{await i.waitReady;let{callId:p,method:d,args:R}=o;try{let f=await l[d](...R);s.postMessage({type:"rpc-return",callId:p,result:f})}catch(f){console.error(f),s.postMessage({type:"rpc-error",callId:p,error:{message:f.message}})}break}}}),s.postMessage({type:"connected"})}function X(g,i){let e=null,r=null,a=`pglite-tab-close:${g}`;return q(a).then(()=>{r&&i.exec("ROLLBACK"),e?.(),r?.()}),{async getDebugLevel(){return i.debug},async close(){await i.close()},async execProtocol(s){let{messages:l,data:n}=await i.execProtocol(s);if(n.byteLength!==n.buffer.byteLength){let o=new ArrayBuffer(n.byteLength),p=new Uint8Array(o);return p.set(n),{messages:l,data:p}}else return{messages:l,data:n}},async execProtocolRaw(s,l={}){let n=await i.execProtocolRaw(s,l);if(n.byteLength!==n.buffer.byteLength){let o=new ArrayBuffer(n.byteLength),p=new Uint8Array(o);return p.set(n),p}else return n},async dumpDataDir(){return await i.dumpDataDir()},async syncToFs(){return await i.syncToFs()},async _handleBlob(s){return await i._handleBlob(s)},async _getWrittenBlob(){return await i._getWrittenBlob()},async _cleanupBlob(){return await i._cleanupBlob()},async _checkReady(){return await i._checkReady()},async _acquireQueryLock(){return new Promise(s=>{i._runExclusiveQuery(()=>new Promise(l=>{e=l,s()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(s=>{i._runExclusiveTransaction(()=>new Promise(l=>{r=l,s()}))})},async _releaseTransactionLock(){r?.(),r=null}}}var U=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function q(g){let i;return await new Promise(e=>{navigator.locks.request(g,()=>new Promise(r=>{i=r,e()}))}),i}export{U as LeaderChangedError,H as PGliteWorker,se as worker};
+import{a as j}from"../chunk-6JG4A6NZ.js";import{u as N,x as z}from"../chunk-4LH4BY34.js";import"../chunk-STOZMFXW.js";import{e as t,f as h,g as u,h as y,j as Q}from"../chunk-BTBUZ646.js";Q();var W,T,C,M,_,m,L,x,k,B,A,O,E,v,G,P,b,I,$,c,K,D,w,J,F=class F extends j{constructor(e,r){super();h(this,c);h(this,W);h(this,T,0);h(this,C,!1);h(this,M,!1);h(this,_,!1);h(this,m,new EventTarget);h(this,L);h(this,x,!1);h(this,k);h(this,B);h(this,A);h(this,O);h(this,E);h(this,v);h(this,G);h(this,P,new Map);h(this,b,new Set);h(this,I);h(this,$,[]);u(this,k,e),u(this,L,N()),u(this,I,r?.extensions??{}),u(this,A,new Promise(a=>{t(this,k).addEventListener("message",s=>{if(s.data.type==="here")a();else throw new Error("Invalid message")},{once:!0})})),u(this,O,new Promise(a=>{let s=l=>{l.data.type==="ready"&&(u(this,B,l.data.id),t(this,k).removeEventListener("message",s),a())};t(this,k).addEventListener("message",s)})),u(this,W,y(this,c,K).call(this,r))}static async create(e,r){let a=new F(e,r);return await t(a,W),a}get waitReady(){return new Promise(e=>{t(this,W).then(()=>{t(this,x)?e():e(new Promise(r=>{t(this,m).addEventListener("connected",()=>{r()})}))})})}get debug(){return t(this,T)}get ready(){return t(this,C)}get closed(){return t(this,M)}get isLeader(){return t(this,_)}async close(){var e;t(this,M)||(u(this,M,!0),t(this,E)?.close(),t(this,v)?.close(),(e=t(this,G))==null||e.call(this),t(this,k).terminate())}async[Symbol.asyncDispose](){await this.close()}async execProtocolRaw(e){return await y(this,c,w).call(this,"execProtocolRaw",e)}async execProtocol(e){return await y(this,c,w).call(this,"execProtocol",e)}async syncToFs(){await y(this,c,w).call(this,"syncToFs")}async listen(e,r,a){let s=z(e),l=a??this;return t(this,P).has(s)||t(this,P).set(s,new Set),t(this,P).get(s).add(r),await l.exec(`LISTEN ${e}`),async n=>{await this.unlisten(s,r,n)}}async unlisten(e,r,a){await this.waitReady;let s=a??this;r?t(this,P).get(e)?.delete(r):t(this,P).delete(e),t(this,P).get(e)?.size===0&&await s.exec(`UNLISTEN ${e}`)}onNotification(e){return t(this,b).add(e),()=>{t(this,b).delete(e)}}offNotification(e){t(this,b).delete(e)}async dumpDataDir(compression){return await y(this,c,w).call(this,"dumpDataDir",compression)}onLeaderChange(e){return t(this,m).addEventListener("leader-change",e),()=>{t(this,m).removeEventListener("leader-change",e)}}offLeaderChange(e){t(this,m).removeEventListener("leader-change",e)}async _handleBlob(e){await y(this,c,w).call(this,"_handleBlob",e)}async _getWrittenBlob(){return await y(this,c,w).call(this,"_getWrittenBlob")}async _cleanupBlob(){await y(this,c,w).call(this,"_cleanupBlob")}async _checkReady(){await this.waitReady}async _runExclusiveQuery(e){await y(this,c,w).call(this,"_acquireQueryLock");try{return await e()}finally{await y(this,c,w).call(this,"_releaseQueryLock")}}async _runExclusiveTransaction(e){await y(this,c,w).call(this,"_acquireTransactionLock");try{return await e()}finally{await y(this,c,w).call(this,"_releaseTransactionLock")}}};W=new WeakMap,T=new WeakMap,C=new WeakMap,M=new WeakMap,_=new WeakMap,m=new WeakMap,L=new WeakMap,x=new WeakMap,k=new WeakMap,B=new WeakMap,A=new WeakMap,O=new WeakMap,E=new WeakMap,v=new WeakMap,G=new WeakMap,P=new WeakMap,b=new WeakMap,I=new WeakMap,$=new WeakMap,c=new WeakSet,K=async function(e={}){for(let[o,p]of Object.entries(t(this,I))){if(p instanceof URL)throw new Error("URL extensions are not supported on the client side of a worker");{let d=await p.setup(this,{},!0);if(d.emscriptenOpts&&console.warn(`PGlite extension ${o} returned emscriptenOpts, these are not supported on the client side of a worker`),d.namespaceObj){let R=this;R[o]=d.namespaceObj}d.bundlePath&&console.warn(`PGlite extension ${o} returned bundlePath, this is not supported on the client side of a worker`),d.init&&await d.init(),d.close&&t(this,$).push(d.close)}}await t(this,A);let{extensions:r,...a}=e;t(this,k).postMessage({type:"init",options:a}),await t(this,O);let s=`pglite-tab-close:${t(this,L)}`;u(this,G,await q(s));let l=`pglite-broadcast:${t(this,B)}`;u(this,E,new BroadcastChannel(l));let n=`pglite-tab:${t(this,L)}`;u(this,v,new BroadcastChannel(n)),t(this,E).addEventListener("message",async o=>{o.data.type==="leader-here"?(u(this,x,!1),t(this,m).dispatchEvent(new Event("leader-change")),y(this,c,D).call(this)):o.data.type==="notify"&&y(this,c,J).call(this,o.data.channel,o.data.payload)}),t(this,v).addEventListener("message",async o=>{o.data.type==="connected"&&(u(this,x,!0),t(this,m).dispatchEvent(new Event("connected")),u(this,T,await y(this,c,w).call(this,"getDebugLevel")),u(this,C,!0))}),t(this,k).addEventListener("message",async o=>{o.data.type==="leader-now"&&(u(this,_,!0),t(this,m).dispatchEvent(new Event("leader-change")))}),y(this,c,D).call(this),this._initArrayTypes()},D=async function(){t(this,x)||(t(this,E).postMessage({type:"tab-here",id:t(this,L)}),setTimeout(()=>y(this,c,D).call(this),16))},w=async function(e,...r){let a=N(),s={type:"rpc-call",callId:a,method:e,args:r};return t(this,v).postMessage(s),await new Promise((l,n)=>{let o=R=>{if(R.data.callId!==a)return;d();let f=R.data;if(f.type==="rpc-return")l(f.result);else if(f.type==="rpc-error"){let S=new Error(f.error.message);Object.assign(S,f.error),n(S)}else n(new Error("Invalid message"))},p=()=>{d(),n(new U)},d=()=>{t(this,v).removeEventListener("message",o),t(this,m).removeEventListener("leader-change",p)};t(this,m).addEventListener("leader-change",p),t(this,v).addEventListener("message",o)})},J=function(e,r){let a=t(this,P).get(e);if(a)for(let s of a)queueMicrotask(()=>s(r));for(let s of t(this,b))queueMicrotask(()=>s(e,r))};var H=F;async function se({init:g}){postMessage({type:"here"});let i=await new Promise(p=>{addEventListener("message",d=>{d.data.type==="init"&&p(d.data.options)},{once:!0})}),e=i.id??`${import.meta.url}:${i.dataDir??""}`;postMessage({type:"ready",id:e});let r=`pglite-election-lock:${e}`,a=`pglite-broadcast:${e}`,s=new BroadcastChannel(a),l=new Set;await q(r);let n=g(i);s.onmessage=async p=>{let d=p.data;switch(d.type){case"tab-here":V(d.id,await n,l);break}},s.postMessage({type:"leader-here",id:e}),postMessage({type:"leader-now"}),(await n).onNotification((p,d)=>{s.postMessage({type:"notify",channel:p,payload:d})})}function V(g,i,e){if(e.has(g))return;e.add(g);let r=`pglite-tab:${g}`,a=`pglite-tab-close:${g}`,s=new BroadcastChannel(r);navigator.locks.request(a,()=>new Promise(n=>{s.close(),e.delete(g),n()}));let l=X(g,i);s.addEventListener("message",async n=>{let o=n.data;switch(o.type){case"rpc-call":{await i.waitReady;let{callId:p,method:d,args:R}=o;try{let f=await l[d](...R);s.postMessage({type:"rpc-return",callId:p,result:f})}catch(f){console.error(f),s.postMessage({type:"rpc-error",callId:p,error:{message:f.message}})}break}}}),s.postMessage({type:"connected"})}function X(g,i){let e=null,r=null,a=`pglite-tab-close:${g}`;return q(a).then(()=>{r&&i.exec("ROLLBACK"),e?.(),r?.()}),{async getDebugLevel(){return i.debug},async close(){await i.close()},async execProtocol(s){let{messages:l,data:n}=await i.execProtocol(s);if(n.byteLength!==n.buffer.byteLength){let o=new ArrayBuffer(n.byteLength),p=new Uint8Array(o);return p.set(n),{messages:l,data:p}}else return{messages:l,data:n}},async execProtocolRaw(s,l={}){let n=await i.execProtocolRaw(s,l);if(n.byteLength!==n.buffer.byteLength){let o=new ArrayBuffer(n.byteLength),p=new Uint8Array(o);return p.set(n),p}else return n},async dumpDataDir(compression){return await i.dumpDataDir(compression)},async syncToFs(){return await i.syncToFs()},async _handleBlob(s){return await i._handleBlob(s)},async _getWrittenBlob(){return await i._getWrittenBlob()},async _cleanupBlob(){return await i._cleanupBlob()},async _checkReady(){return await i._checkReady()},async _acquireQueryLock(){return new Promise(s=>{i._runExclusiveQuery(()=>new Promise(l=>{e=l,s()}))})},async _releaseQueryLock(){e?.(),e=null},async _acquireTransactionLock(){return new Promise(s=>{i._runExclusiveTransaction(()=>new Promise(l=>{r=l,s()}))})},async _releaseTransactionLock(){r?.(),r=null}}}var U=class extends Error{constructor(){super("Leader changed, pending operation in indeterminate state")}};async function q(g){let i;return await new Promise(e=>{navigator.locks.request(g,()=>new Promise(r=>{i=r,e()}))}),i}export{U as LeaderChangedError,H as PGliteWorker,se as worker};
 //# sourceMappingURL=index.js.map
